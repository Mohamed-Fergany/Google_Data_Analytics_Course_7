---
title: "A Quick Intro for R Beginners"
author: 
  name: "Mohamed Fergany Omran" 
  email: "mohamed.fergany.omran@gmail.com"
date: "2/28/2022"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
  html_document:
    theme: united
    highlight: tango
    df_print: paged
---

## Hi everyone,

This notebook is a summarization of the [Google Introductory Course to R Programming](https://www.coursera.org/learn/data-analysis-r/home/welcome "Google"){style="(color: blue)"} the seventh course of the Google Data Analytics Certificate.\
Personally I highly recommend to take that course if you wanna start learning R.

It covers its contents and as you go through the notebook you'll find more resources attached in the markdown. During my enrollment, I've made this notebook as a learn-by-practice approach and to spread the knowledge as much as I can with my fellow aspiring data analysts.

Hope this notebook is useful for you and if you have anything you wanna modify, I'm looking forward for the feed backs.

Before we write our first code, kindly read the following quotes by [Yihui Xie](https://bookdown.org/yihui/rmarkdown-cookbook/cache.html). You'll know why this is a very important tip as you proceed.

> "When a code chunk is time-consuming to run, you may consider caching it via the chunk option `cache = TRUE`. When the cache is turned on, knitr will skip the execution of this code chunk if it has been executed before and nothing in the code chunk has changed since then. When you modify the code chunk."

> "We do not recommend that you set the chunk option `cache = TRUE` globally in a document. Caching can be fairly tricky. Instead, we recommend that you enable caching only on individual code chunks that are surely time-consuming and do not have side effects."

*Speaking of code chunks, the easiest way to add code chunks is to press\
(ctrl + alt + I). Also you may wanna rename your code chunks `{r chunk_name}` to easily find that code chunk from the toggle menu above the console pane.*

```{r}
# Run the following code to specify the options for all code chunks in the
# markdown without having to specify the options for each single chunk
knitr::opts_chunk$set(
  echo = TRUE, # Show the input code chunks in your document
  message = FALSE, 
  warning = FALSE, 
  cache =TRUE
) 
```

*Remember you can change the settings of any code chunk from the gear symbol at the top right of the chunk*

> *"If your script uses add-on packages, load them all at once at the very beginning of the file. This is more transparent than sprinkling library() calls throughout your code*" Hadley Wickham

```{r packages}
# First load the required packages and the datasets
library(tidyverse)
library(palmerpenguins)
library(lubridate)
library(readxl)
library(here)
library(skimr)
library(janitor)
library(directlabels)
```

Now let's explore the [Tidyverse package](https://www.tidyverse.org/)

*In short the tidyverse core consists of eight [packages](https://www.tidyverse.org/packages/). But there're four packages that are an essential part of the workflow for data analysts (ggplot2, dplyr, tidyr and readr). You'll most likely use these more often than the others.*

\newpage

```{r}
# Load the dataset
data("penguins")
```

To view the entire dataset in a new window use *`View(penguins)`.*

```{r}
# To output the first n rows 
head(penguins,5)

# To output the last n rows
tail(penguins,12)
```

```{r}
# To output a specific row(s) 
# syntax: dataset[row number(s),column number(s)]
# For a range
penguins[1:5,] 

# For a specified no of rows
penguins[c(2,5),]

# To output the entire row for a specific column(s)
penguins[1:3]
```

```{r}
# To output specific columns by name for a specific range
# Note the (levels) that appear in the code output. 
# They're basically the unique values of the selected column
penguins$island[2:8]

# for a specific list of rows
penguins$island[c(2,8)]
```

*Kindly refer to this [brief introduction to vectors](https://drive.google.com/file/d/1V_6Ssp2FcEvs6JXhPEBlEwoe3kGvb7oj/view?usp=sharing) as you proceed.*

```{r}
# For atomic vectors, we can't input more than one data type 
# (character, double, integer, logical) in the same vector 
vec = c("ok", "this", "is_a_trial")

# To know the type of data in a specific vector
typeof(vec)

# To assign names for vector elements (optional)
names(vec) = c("a", "b", "c")

# To output specifc element of a vector either by using the element name
vec["c"]

# Or by the element number(s) 
vec[2]
vec[c(2, 3)]

# To output the length of a vector
length(vec)
```

```{r}
# Unlike atomic vectors, When using lists we may include more than one data type
# as follows
new_list = list(1L, 5.2, "Ok", TRUE, NULL)

# Similarly, we could also assign a name to each element
names(new_list) = c("a", "b", "c", "d", "e")

# To know the datatype of each element
str(new_list)
```

```{r}
# Alternatively you can assign name while you're creating the list as follows
another_list = list("a" = 1L, "b" = 5.3, "c" = "OK", "d" = FALSE)
names(another_list)
```

*For more information about vectors, you may refer to this [chapter](https://r4ds.had.co.nz/vectors.html#vectors).*

```{r}
# To compare two floating numbers using a specified tolerance. 
# Obviously, this is more useful than just using (==)
dplyr::near(4.56161, 4.56, tol = 0.01)
```

*Kindly refer to this* [Introduction](https://www.coursera.org/learn/data-analysis-r/supplement/g0l4l/dates-and-times-in-r) *and [Cheat Sheet](https://drive.google.com/file/d/16iP4ZMl3KnD6OThP0QoOKOyqASKDkkDu/view?usp=sharing) as you follow along*

```{r}
# After loading the lubridate libray, let's make some codes to learn more 
# about it. 
# For the date in Calgary, Canada
today(tzone = 'MST') 

# The time difference in hours between Cairo & Calgary
calgary = now(tzone = "MST")
cairo = now(tzone = "EET")  
cat((hour(cairo) - hour(calgary)),"hrs")
```

```{r}
# Some examples to convert strings into datetime format. 
# Note how we should use the right function that matches the string order
# All datetimes will be shown in the default format 
# (yyyy-mm-dd hh:mm:ss UTC)
dmy("6th of October 2021")
dmy_hms("13 of January 1993 10:59:12 PM")
mdy_hm("November 13th 2014 10:13") 
```

```{r}
# To extract specific part of the datetime 
minute(dmy_hms("13 of January 1993 10:59:12 PM"))
second(dmy_hms("13 of January 1993 10:59:12 PM"))
year(dmy_hms("13 of January 1993 10:59:12 PM"))
week(calgary)
```

*As usual refer to this [reading](https://www.coursera.org/learn/data-analysis-r/supplement/xEM9d/other-common-data-structures) and this [site](http://statseducation.com/Introduction-to-R/modules/getting%20data/data-wrangling/) for more info about the following subject.*

```{r}
# First let's start with this creating a simple dataframe
new_df = data.frame(
                name = c("mohamed", "aly", "farid"), 
                salary = c(15000, 12000, 16500)
              )
new_df

# Or by using the tribble funciton
new_tibble = tribble(
               ~name, ~salary,
               "mohamed", 15000,
               "aly", 12000,
               "farid", 16500
             )
new_tibble
```

```{r}
# To separate a column
x_df = tribble(
          ~name, ~age, ~email,
          "aly_kamal", 25, "aly_kamal@gmail",
       )

x_df %>%
  separate(name, c("first", "last"), sep = "_")
```

```{r}
# To see all available built in datasets in R and their installed packages
data()
```

*The list of available datasets will appear in a new window. That's why you can't see the output of the above code anyway here's a glimpse of what will appear.*

![](data().JPG){width="6in" height="3in"}

```{r}
# To load a built in dataset,specify its name and package 
who_data = read_builtin("who", "tidyr")
```

```{r}
# To show columns names, datatype in each column and the values you can use
str(who_data)

# Or
glimpse(who_data)
```

```{r}
# To show only the number and names of the datasets columns
print(colnames(who_data))
```

```{r}
# To rename a column(s)
# Either temporarily
rename(who_data, sp_m1524 = new_sp_m1524)
```

```{r}
# Or permanently 
who_data = rename(who_data, sp_m1524 = new_sp_m1524, iso = iso2)
```

```{r}
# We may also use summarize() to show summary statistics
# You'll learn more about pipes (%>%) later in this notebook
who_data %>% 
  summarise(
    latest_year = max(year, na.rm = TRUE),
    average_sp = mean(c(new_sp_f5564, new_sp_f65, new_sn_m014), na.rm = TRUE)
  )

```

*Always set `na.rm = TRUE` to remove the null values during calculation and avoid getting NA in the results.*

```{r}
# To load a dataset either from the web or by uploading it
# Note that each file may contain only one sheet and be in the CSV format
world_happiness = read_csv(
                    "World_Happiness_data.csv",
                    show_col_types = FALSE
                  )
world_happiness
```

```{r}
# To view the list of sheets for an excel file
excel_sheets("CO2 Dataset.xlsx")

# Paste the file path and the sheet name
co2_df = read_excel(
           "CO2 Dataset.xlsx", 
           sheet = "CO2 Data Cleaned"
         )
```

```{r}
# We may create new directories and new files as follows
# If they're created successfully, TRUE will appear in the code output
dir.create("trial_dir")
dir.create("new_dir")
file.create("new_file.csv")
```

```{r}
# We may create matrices using the matrix() function provided the elements and 
# the number of rows or the number of cols
matrix_a = matrix(c(3:14), nrow = 4)
matrix_b = matrix(c(20:31), nrow = 3)
```

```{r}
# For matrices multiplication, use the (%*%) operator
# The number of columns of the first one must equal the number of rows of the 
# second
matrix_c = matrix_b %*% matrix_a
```

*Check out this link to know more about [operators and conditions](https://drive.google.com/file/d/1b7ZeDWQJ0IU9WhOMRmTpcDc6LCqX5Qr7/view?usp=sharing)*

```{r}
# First check the simple examples below
x = 5 
x > 3 & x < 8
x > 7 & x == 5  # TRUE & FALSE = FALSE
x > 5 | x == 3  # | is the same as ||
x != 8
y = 0
!y # As y equals zero, not zero is TRUE

# Now if we have a multiple values/elements
price <- c(100, 20, 5, 200, 60, 88, 190, 33, 290, 64)
price > 50
```

```{r}
x = c(12, 15, 20)
y = c(13, 16, 34)

# In case of element-wise logical operators, each single element will be checked
x & y < 15

# In the other case, the first element only will be checked
x && y < 15

# A quick note regarding arithmatic operators (%%) and (%/%)
7 %% 3
7 %/% 3
```

```{r}
# If we wanna choose a variable name that's a reserved word (TRUE, in, etc.) or
# starts with an (_), we must use backticks (` `) to avoid getting errors.
`TRUE` = 18
`_x01` = 21
`TRUE`
`_x01`
```

```{r}
# (<<-) is an assigment operator that's mainly used in functions. 
# For instance if we wanna change change the global value of a variable inside a
# function as follows.
x <- 1
y <- 3
fun_3 <- function() {
          x <- 2
          y <<- 5
          print(paste(x, y))
}

fun_3() 
x # (the value hasn't changed)
y # (the value has changed)
```

```{r}
# To access functions of a pacakge use the (::) operators
# Enter the package name then (::) and press tab to view the list of functions
lubridate::.__C__Interval 
```

```{r}
# We may filter a dataframe based on logical condtion(s) using the filter() function
filter(who_data, country == c("Afghanistan",'Albania') & year > 1990)
```

```{r}
# Let's see an example of how the if,else and else if can be used in R
# Note the code syntax. To make sure you fully get it try to apply some changes
# and see the results
# & and | should never be used inside of an if clause because they can return 
# vectors. Always use && and || instead.
if (who_data[100,]['country'] %in% 
  c('China','Afghanistan','SaudiArabia')) {
  print("Asian Country")
} else if (who_data[100,]['country'] == 'Algeria') {
  print("African Country")
} else {
  print("European Country")
}
```

```{r}
# To show the unique values of a column
print(unique(who_data['country']))
```

### Note for using if

when you run the above code you can see that Egypt, Algeria and Senegal are in the countries list. However when you run the code below, you'll get "not exist" and that's because when using if for more than one element, it'll look through the first element/row only and in our dataframe the country in the first row is 'Afghanistan' hence we got the 'not exist' result.

```{r}
if (who_data['country'] %in% c("Egypt", 'Algeria', 'Senegal')) {
  print("ok")
} else {
  print("not exist")
}
```

*Additional notes by Google on* [Keeping your code readable](https://drive.google.com/file/d/1p0njnrFYsLpMcKcNojmiW_eqL4FyJvv3/view?usp=sharing)

*Check out this chapter on [Pipes](https://r4ds.had.co.nz/pipes.html) as you proceed through the following*

```{r}
# We shall use the (ToothGrowth) dataset to explore the pipes tool
tg_df = read_builtin("ToothGrowth","datasets")
tg_df
```

```{r}
# Let's say we want to the effectiveness of each supplement on teeth
# Always remeber to indent every new line of code in the pipe
supp_effect <- tg_df %>%
  group_by(supp) %>%
  summarise(
    average_length = mean(len, na.rm = TRUE),
    average_dose = mean(dose, na.rm = TRUE),
  )
supp_effect
```

```{r}
# Now let's try a new dataframe from the ggplot2 package
diamond_df = read_builtin("diamonds", "ggplot2")

# We may create new column(s) and specify their locations and values either by
# add_column() or mutate()
diamond_df = add_column(
               diamond_df, 
               category = "low_price",
              .before = "cut"
             )
diamond_df$category[
             diamond_df$price > 1000 & 
             diamond_df$price < 10000 
           ] = 'Meduim Price'
diamond_df$category[diamond_df$price > 10000] = "High Price"
```

```{r}
# Let's say for easier interpretation we wanna create a dataframe that has only
# selected columns of the original dataframe.
cut_to_price = select(diamond_df, colnames(diamond_df)[3:8])
cut_to_price
# On the other hand, if we wanna exclude specific columns
select(diamond_df, -colnames(diamond_df)[c(3,8)])
```

```{r}
# The readr package has 8 buitlin datasets of different formats 
# (csv, txt, zip, etc.)
readr_example()

# To load anyone of those datasets
read_csv(readr_example('mtcars.csv'), show_col_types = FALSE)
```

```{r}
# we may even read a compressed file and the read_csv function will decompress
# it.
mt_cars = read_csv(readr_example('mtcars.csv.zip'), show_col_types = FALSE)
mt_cars
```

```{r}
# We may create a new file in the directory and put/write data in it 
file.create("massey_rating")
mr = read_file(readr_example('massey-rating.txt'))
write_file(mr, file = "massey_rating")
```

```{r}
# To get summarized statistics about the dataframe
skim_without_charts(co2_df)

# We may also use the summary() function
summary(co2_df)

# Now if we wanna make our columns names lower case and consists only of letters
# numbers and underscores
co2_df = clean_names(co2_df)

co2_df %>% 
  group_by(country_name) %>%
  summarize(average_emissions = mean(co2_per_capita_metric_tons, na.rm = TRUE))

# We can create a new column that's the sum of multiple columns as follows
co2_df = co2_df %>%
  mutate(
    'total' = rowSums(
                co2_df[,c('co2_per_capita_metric_tons', 'co2_kt')],
                na.rm = TRUE
              )
  ) 
head(co2_df)

# If we want to get the sum of each column separately
colSums(co2_df[,c('co2_per_capita_metric_tons', 'co2_kt')], na.rm = TRUE)
```

```{r}
# If we wanna merge multiple column into a single one
# Set remove to FALSE if you also wanna keep the original columns
co2_df = co2_df %>%
  unite(
    combined, 
    c("country_name", "co2_per_capita_metric_tons", "year"),
    sep = "/"
  )
co2_df

# Now let's do the reverse process
co2_df = co2_df %>%
  separate(
    combined, 
    c("country_name", "co2_per_capita_metric_tons", "year"),
    sep = "/"
  )
co2_df
```

*To learn more about [Pivoting](https://tidyr.tidyverse.org/articles/pivot.html)*

```{r}
beachbugs_wide = read_csv('beachbugs_wide.csv')
head(beachbugs_wide)

bb_long = beachbugs_wide %>%
  pivot_longer(
    cols = colnames(beachbugs_wide)[2:12],
    names_to = 'beach',
    values_to = 'bugs'
  )
head(bb_long)

beachbugs_long = read_csv("beachbugs_long.csv")
head(beachbugs_long)

bb_wide = beachbugs_long %>%
  pivot_wider(
    names_from = 'site',
    values_from = 'buglevels'
  )
head(bb_wide)
```

### Note that every plot in the gglpot package must start with the ggplot()

### function where you specify the dataset.

Bar plots can be used to show the count of each categorical value in one variable only. If we want to used the bar plot for two variables, we use the column chart. However it's better to use scatter plots and heat maps. Let's try this simple column & scatter plots to see the difference.

```{r}
ggplot(drop_na(penguins)) + 
  geom_col(mapping = aes(flipper_length_mm, body_mass_g, fill = sex))
```

```{r}
ggplot(
  drop_na(penguins),
  # We may change the opaquity of the points using the alpha aesthetic to     
  # be able to see whether if there're points plotted on top of each other
  # For instance, setting the alpha = 0.25 means that four points staked      
  # on top of each other will create a solid point.
  aes(flipper_length_mm, body_mass_g, color = sex, alpha = 0.25)
) +
  # When plotting large number of points, it's quite useful to use geom_smooth
  # to clearly see the overall relationship between the variables.
  geom_smooth(se = FALSE) +
  geom_point(show.legend = FALSE) +
  # To apply labels inside the chart
  geom_dl(aes(label = sex, fontface = "italic"), method = "smart.grid") +
  # To add titles, subtitles, captions, y and x labels
  labs(
    title = "Flipper length vs Body mass",
    # Subtitles are usually used to highlight important information
    subtitle = "The relation between body mass and the flipper length",
    # Caption let us show the source of our data
    caption = "Data collected by Dr. Kristen Gorman",
    x = "Flipper length (mm)",
    y = "Body mass (g)"
  ) +
  # Another way to (manually) add the labels or create shapes
  annotate(
    geom = "segment",
    x = c(204, 200),
    xend = c(204, 200),
    y = c(3200, 4800),
    yend = c(4000, 4150),
    color = c("lightcoral", "lightblue"),
    size = c(0.45, 0.45),
    angle = c(90, 90),
    arrow = arrow()
  )
```

```{r}
# We may also use the geom_count to visualize the relationship between 
# the flipper_length and the body_mass in addition to the frequency of 
# value.

count_table = drop_na(penguins) %>%
  count(flipper_length_mm, body_mass_g) 
count_table

ggplot(
  drop_na(penguins), 
  aes(flipper_length_mm, body_mass_g, shape = sex)
) + 
  geom_count() 

```

```{r}
drop_na(penguins) %>%
  count(island, species) %>%
  ggplot() +
  geom_tile(mapping = aes(island,species,fill = n))
```

Now let's say we wanna create a bar plot that shows the number of each species per island and apply customized color to each species. Note that the default position is the stack one. There's also the dodge so fill feel free to try each of them. We could create multiple plots using facet_grid as follows.

```{r fig.height=8, fig.width=8}
ggplot(drop_na(penguins), aes(island, fill = species)) +
  geom_bar(show.legend = FALSE, width = 0.3, position = "stack") +
  # Select desired colors either by name or code
  scale_fill_manual(values = c("#00AFBB", "#E7B300", "#FC4E07")) +
  facet_wrap(sex ~ ., ncol = 1, strip.position = "top") +
  scale_y_continuous(limits = c(0, 90), n.breaks = 10) +
  theme(
    axis.text = element_text(size = 15, angle = 45),
    axis.text.x = element_text(vjust = 0.65),
    axis.title = element_text(size = 25, color = "steelblue"),
    strip.text = element_text(size = 20, color = "steelblue"),
    strip.background = element_blank()
  ) +
  # If we wanna to show label(s) on each bar
  stat_count(
    geom = "text",
    colour = "black",
    size = 5,
    aes(label = species),
    position = position_stack(vjust = 0.5)
  ) +
  stat_count(
    geom = "text",
    color = "black",
    size = 4,
    position = position_stack(vjust = 0.28),
    aes(label = ..count..)
  )
```

We may define Histograms as similar of barplots except they're used for quantitative variables.

```{r fig.height=8, fig.width=8}
ggplot(penguins, aes(bill_length_mm, fill = species)) + 
  geom_histogram(show.legend = FALSE, col = 'grey') + 
  scale_fill_manual(values = c("ForestGreen", "#E7B300", "#FC4E07")) + 
  facet_wrap(species ~ ., strip.position = 'top', ncol = 1) + 
  theme(
   axis.title = element_text(size = 20),
   strip.text = element_text(size = 20),
   axis.text = element_text(size = 15)
  ) +  
  scale_y_continuous(limits = c(0,25))

# To save the plot separately in a specific format
ggsave("penguins_2.png")
```

```{r}
# Another example
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = color, fill = cut)) +
  facet_wrap(.~cut)
```

There are three alternatives to the histogram as well

```{r fig.height=8, fig.width=8}
# Density plot
ggplot(penguins, aes(bill_length_mm, fill = species)) + 
  geom_density(show.legend = FALSE) + 
  scale_fill_manual(values = c("ForestGreen", "#E7B300", "#FC4E07")) + 
  facet_wrap(species ~ ., ncol = 1, strip.position = 'top') + 
  scale_x_continuous(limits = c(20,60), n.breaks = 5) + 
  theme(
   axis.text = element_text(size = 15, angle = 45),
   axis.title = element_text(size = 20),
   strip.text = element_text(size = 20)              
  )
```

```{r fig.height=8, fig.width=8}
# Frequency plot
ggplot(penguins, aes(bill_length_mm, color = species)) + 
  geom_freqpoly(show.legend = FALSE) + 
  scale_color_manual(values = c("ForestGreen", "#E7B300", "#FC4E07")) + 
  facet_grid(species ~ .) + 
  scale_x_continuous(limits = c(20,60), n.breaks = 5) + 
  scale_y_continuous(limits = c(0,30), n.breaks = 6) + 
  theme(
    axis.text = element_text(size = 15, angle = 45),
    axis.title = element_text(size = 20),
    strip.text = element_text(size = 20)
  )
```

```{r fig.height=8, fig.width=8}
# Dot plot
ggplot(penguins, aes(bill_length_mm, fill = species)) + 
  geom_dotplot(show.legend = FALSE) +
  scale_fill_manual(values = c("ForestGreen", "#E7B300", "#FC4E07")) + 
  facet_wrap(species ~ ., ncol = 1, strip.position = 'top') + 
  scale_x_continuous(limits = c(20,60), n.breaks = 5) + 
  theme(
    axis.title = element_text(size = 20),
    axis.text = element_text(size = 15),
    strip.text = element_text(size = 20)
  )
```

\newpage

Now when working with Box plots, always keep in mind these two main notes: a) Box plots are usually used to plot qualitative vs. quantitative variables b) Any value \> 1.5\*IQR will be plotted as an outlier

```{r fig.height=8, fig.width=8}

ggplot(drop_na(penguins), aes(species, body_mass_g, fill = species)) + 
  geom_boxplot(
      show.legend = FALSE,
      outlier.shape = 21, # A number 0:25 , NA will hide the outliers
      outlier.size = 3,
      outlier.fill = 'red'
  ) + 
  facet_wrap(sex ~ ., scales = 'free_x', ncol = 1, strip.position = 'top') + 
  scale_y_continuous(limits = c(2500,6500), n.breaks = 10)  + 
  theme(
    axis.text = element_text(angle = 45, size = 15),
    axis.text.x = element_text(vjust = 0.65),
    axis.title = element_text(size = 20, color = 'steelblue'),
    strip.text = element_text(size = 20, color = 'steelblue')
  ) +
  ylim(3000, 6000) # To zoom in a specified portion of the plot (with clipping)
```

*Note that zoom with clipping removes the excluded point and recreate the plot*

Another similar plot is the violin plot. note how each violin shape gets thicker and thinner corresponding to the frequency of each value.

```{r fig.height=12, fig.width=8}

ggplot(drop_na(penguins),aes(species, body_mass_g, fill = species)) + 
  geom_violin(
      show.legend = FALSE,
      outlier.shape = 21, # A number 0:25 , NA will hide the outliers
      outlier.size = 3,
      outlier.fill = 'red',
      draw_quantiles = c(0.25, 0.5, 0.75)
  ) + 
  facet_wrap(sex ~ ., scales = 'free_x', ncol = 1) + 
  scale_y_continuous(limits = c(2000,7000), n.breaks = 10) + 
  theme(
    axis.text = element_text(angle = 45, size = 15),
    axis.text.x = element_text(vjust = 0.65),
    axis.title = element_text(size = 20, color = 'steelblue'),
    strip.text = element_text(size = 20, color = 'steelblue')
  ) +
  # To zoom without clipping use coord_cartesian() as follows.
  coord_cartesian(ylim = c(2500, 6500)) 
```

If we want to plot two continuous variables using box plots. we may use cut_interval/cut_number/cut_width. Those cut functions basically group the values into a specified number of categories as shown below.

*Note: If we don't wanna the source code to appear highlighted in the final rendered file, we set highlight = FALSE as shown below.*

```{r fig.height=8, fig.width=8, highlight=FALSE}

penguins %>%
  ggplot(
    aes(
      flipper_length_mm, 
      body_mass_g, 
      group = cut_interval(flipper_length_mm, n = 4),
      fill = cut_interval(flipper_length_mm, n = 4),
    )
  ) + 
  geom_boxplot(show.legend = FALSE) +
  scale_y_continuous(limits = c(2500, 6500), n.breaks = 20)
```

### Introduction to Rmarkdown

You may refer to the following [Link](https://www.coursera.org/learn/data-analysis-r/supplement/NSC0c/r-markdown-resources) for further resources.

``` r
add a code block inside the text like this one using insert->code block
```

\newpage

We may create the table like the one below using table shown in the top right.

| First Name | Last Name |          Email          |
|:----------:|:---------:|:-----------------------:|
|    Aly     |   Kamel   |  aly.kamel\@gmail.com   |
|  Mohamed   |  Mustafa  | mo.mustafa\@outlook.com |

: This is a trial table

-   We may choose different \textcolor{green}{colors} for our text. by writing the \textcolor{red}{desired color names}.

-   To add a superscript add \^ before and after the super scripted text (x^2^)

-   To create an equation: $Circle Area = \pi*r^2$

-   Another method to create an equation is to choose display math from insert drop down list. $$A = \pi * r^2$$

------------------------------------------------------------------------

To add a horizontal ruler before or after a text just type (\*\*\*)

------------------------------------------------------------------------

> You may add a quote inside the text also by selecting the block quote symbol above.

\newpage

\
An image can simply be inserted using the image symbol above

![you may also add a caption to the image here](penguins_2.png "image_1"){width="6in" height="8in"}

\newpage

*You may create the below dashed line using (---) multiple times*

------------------------------------------------------------------------

below are the main six types of fonts in the markdown files. you can choose any one of them either from the drop down list at the top right or using (ctrl + alt + (0:6))

# Heading_1

## Heading_2

### Heading_3

#### Heading_4

Normal Text

##### Heading_5

###### Heading_6

------------------------------------------------------------------------

We may add definitions in our rmd files from the insert drop down list above

RMD file

:   R Markdown is a file format for making dynamic documents with R. An R Markdown document is written in markdown (an easy-to-write plain text format) and contains chunks of embedded R code.

-   Place code inline with a single back ticks. The first back tick must be followed by an R, like this `r paste("This is an inline code outlet")` . Note that in this case, only the code outlet will be displayed.

-   To write sub_items just enter the plus sign and space.

1.  Item_1

    -   sub_item

        -   sub_sub_item
